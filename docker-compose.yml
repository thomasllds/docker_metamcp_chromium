services:
  app:
    # Au lieu de tirer l'image, on la construit avec notre Dockerfile
    build: 
      context: .
      dockerfile: Dockerfile
    # On garde les variables d'environnement cruciales
    environment:
      - SERVICE_URL_METAMCP_12008
      - 'POSTGRES_HOST=${POSTGRES_HOST:-postgres}'
      - 'POSTGRES_PORT=${POSTGRES_PORT:-5432}'
      - 'POSTGRES_USER=${SERVICE_USER_POSTGRES}'
      - 'POSTGRES_PASSWORD=${SERVICE_PASSWORD_POSTGRES}'
      - 'POSTGRES_DB=${POSTGRES_DB:-metamcp_db}'
      - 'DATABASE_URL=postgresql://${SERVICE_USER_POSTGRES}:${SERVICE_PASSWORD_POSTGRES}@${POSTGRES_HOST:-postgres}:${POSTGRES_PORT:-5432}/${POSTGRES_DB:-metamcp_db}'
      - 'APP_URL=${SERVICE_URL_METAMCP}'
      - 'NEXT_PUBLIC_APP_URL=${SERVICE_URL_METAMCP}'
      - 'BETTER_AUTH_SECRET=${SERVICE_PASSWORD_AUTH}'
      - 'TRANSFORM_LOCALHOST_TO_DOCKER_INTERNAL=${TRANSFORM_LOCALHOST_TO_DOCKER_INTERNAL:-true}'
      # Variables ajout√©es pour forcer le chemin si le Dockerfile ne suffisait pas
      - 'PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium'
      - 'CHROME_PATH=/usr/bin/chromium'
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test:
        - CMD
        - curl
        - '-f'
        - 'http://localhost:12008/health'
      interval: 10s
      timeout: 5s
      retries: 5

  postgres:
    image: 'postgres:16-alpine'
    environment:
      - 'POSTGRES_DB=${POSTGRES_DB:-metamcp_db}'
      - 'POSTGRES_USER=${SERVICE_USER_POSTGRES}'
      - 'POSTGRES_PASSWORD=${SERVICE_PASSWORD_POSTGRES}'
    volumes:
      - 'postgres_data:/var/lib/postgresql/data'
    healthcheck:
      test:
        - CMD-SHELL
        - 'pg_isready -U ${SERVICE_USER_POSTGRES} -d ${POSTGRES_DB:-metamcp_db}'
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data: